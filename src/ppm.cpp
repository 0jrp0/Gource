/*
    Copyright (C) 2009 Johannes Schindelin (johannes.schindelin@gmx.de)

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version
    3 of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ppm.h"


// FrameExporter

FrameExporter::FrameExporter()
    : surface(NULL), pixels(NULL), rowstride(0) {

    //this now assumes the display is setup
    //before the frame exporter is created
    //(which seems reasonable)
    surface = SDL_GetVideoSurface();

    rowstride     = surface->w * 3;
    surfacepixels = new char[(surface->h) * rowstride];
    pixels        = new char[(surface->h) * rowstride];
}

FrameExporter::~FrameExporter() {
    delete[] surfacepixels;
    delete[] pixels;
}

void FrameExporter::dump() {

    glReadPixels(0, 0, surface->w, surface->h,
        GL_RGB, GL_UNSIGNED_BYTE, surfacepixels);

    //invert
    for(int y=0;y<surface->h;y++) {
        for(int x=0;x<rowstride;x++) {
            pixels[x + y * rowstride] = surfacepixels[x + (surface->h - y - 1) *rowstride];
        }
    }

    dumpImpl();
}

extern "C" {
static void *dumper(void *arg) {
    PPMExporter *ppm = static_cast<PPMExporter *>(arg);
    ppm->dumpThr();
    return NULL;
}
};

// PPMExporter

PPMExporter::PPMExporter(std::string outputfile) {

    if(outputfile == "-") {
        output = &std::cout;

    } else {
        filename = outputfile;
        output   = new std::fstream(outputfile.c_str(), std::ios::out | std::ios::binary);

        if(output->fail()) {
            printf("Failed to open '%s' for writing\n", outputfile.c_str());
            exit(1);
        }
    }

    //write header
    sprintf(ppmheader, "P6\n# Generated by Gource\n%d %d\n255\n",
        surface->w, surface->h
    );
	state = 0;
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);
    pthread_create(&tid, NULL, dumper, this);
}

PPMExporter::~PPMExporter() {
    /* tell dump thread to quit */
    pthread_mutex_lock(&mutex);
    state = 2;
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&mutex);

    if(filename.size()>0) ((std::fstream*)output)->close();

    /* wait for thread to quit, then tear down */
    pthread_join(tid, NULL);
    pthread_cond_destroy(&cond);
    pthread_mutex_destroy(&mutex);
}

void PPMExporter::dumpImpl() {
    pthread_mutex_lock(&mutex);
    state = 1;
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&mutex);
}

void PPMExporter::dumpThr() {
    pthread_mutex_lock(&mutex);
    for (;;) {
    	while (state == 0)
	    pthread_cond_wait(&cond, &mutex);
	if (state == 2)
	    break;

	*output << ppmheader;
	output->write(pixels, rowstride * surface->h);
	state = 0;
    }
    pthread_mutex_unlock(&mutex);
}
